\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[IRIS Python Workshop Seesion 1]{General Introduction, Basic Data Types, Functions, Conditionals and Looping}
\author{Christopher Barker}
\institute{IRIS}
\date{October 15, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
\tableofcontents
\end{frame}

\section{Intro to the Class}

\begin{frame}[fragile]{Instructor}

{\large Christopher Barker: \url{PythonCHB@gmail.com} }

\vfill
First computer: Commodore Pet -- 8k RAM, Basic

\vfill
Passed through: Pascal, Scheme, Fortran

\vfill
Then a long Break: Theater Arts Major, Scenery, Lighting...

\vfill
PhD Coastal Engineering: Fortran, then Linux and MATLAB

\vfill
Now: Discovered Python in 1998 -- Never looked back

\end{frame}

\begin{frame}{Python}

{\Large     My Python use now:}
\begin{itemize}
   \item Lots of text file crunching / data processing
   \item Desktop GUIs (wxPython)
   \item Computational code
   \item wrapping C/C++ code      
   \item web apps (Pylons, Pyramid)
   \item GIS processing
   \item Ask me about ``BILS'' 
\end{itemize}
\end{frame}


\begin{frame}{Who are you?}

{\Large A bit about you:}
\begin{itemize}
  \item Name
  \item What do you do at IRIS?
  \item programing background (languages)
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Class Structure}

{\LARGE github project} \\
\url{https://github.com/PythonCHB/IRIS_Python_Class}

\vfill
{\large Presentations, Sample Code, etc:}

{\small
\begin{verbatim}
git clone https://github.com/PythonCHB/IRIS_Python_Class.git
\end{verbatim}
}
\end{frame}

\begin{frame}{Class Structure}

{\Large Very informal structure: more tutorial/workshop than formal class}

\vfill
{\large \bf Class Time:}
  \begin{itemize}
     \item Some lecture, lots of demos
     \item Lab time: lots of hand-on practice
     \item Later, Rinse, Repeat.....
  \end{itemize}

\vfill
Interrupt me with questions -- please!

\vfill
(Some of the best learning prompted by questions)


\end{frame}

\begin{frame}{Python Features}
 
{\Large Gets many things right:}
\begin{itemize}
  \item  Readable -- looks nice, makes sense
  \item  No ideology about best way to program -- 
   object-oriented programming,  functional, etc.
  \item  No platform preference -- Windows, Mac, Linux, ...
  \item  Easy to connect to other languages -- C, Fortran - essential for science/math
  \item  Large standard library 
  \item  Even larger network of external packages
  \item  Countless conveniences, large and small, make it pleasant to work with
\end{itemize}
\end{frame}

\section{What is Python?}

\begin{frame}{What is Python?}
    \begin{itemize}
      \item Dynamic
      \item Object oriented
      \item Byte-compiled
      \item interpreted
      \item ....
    \end{itemize}
\end{frame}


\begin{frame}{Python Features}

{\Large Features:}

\begin{itemize}
  \item  Unlike C, C++, C\#, Java ... More like Ruby, Lisp, Perl, Matlab, Mathematica ...
  \item  Dynamic - no type declarations
    \begin{itemize}
      \item programs are shorter
      \item programs are more flexible
      \item less code means fewer bugs
    \end{itemize}
  \item  Interpreted - no separate compile, build steps - programming process is simpler
\end{itemize}

\end{frame}

\begin{frame}[fragile]{What's a Dynamic language}

{Strong, Dynamic typing.}

 - Type checking and dispatch happen at run-time

\vspace{0.25in}
{\Large \verb!X = A+B!}
\vspace{0.1in}
\begin{itemize}
\pause
  \item What is A?
  \item What is B?
  \item What does it mean to add them?
\vspace{0.2in}
\pause
  \item A and B can change at any time before this process
\end{itemize}

\end{frame} 


\begin{frame}{Duck Typing}

\vspace{0.25in}
{\center \Large ``If it looks like a duck, and quacks like a duck -- it's probably a duck''}

\pause
\vspace{0.5in}
{\center \Large If an object behaves as expected at run-time, it's the right type.}

\end{frame}


\begin{frame}{Python Versions}

{\Large Python 3.* (``py3k'')}

\vfill
Updated version -- removed the ``warts'' allowed to break code

\vfill
(but really not all that different)

\vfill
Adoption is growing fast, but a few key packages still not supported.
(\url{https://python3wos.appspot.com/})

\vfill
{\Large We'll be using Python 2.7}

\end{frame}


\begin{frame}{Implementations}

\begin{itemize}
    \item Jython (JVM)
    \item Iron Python (.NET)
    \item PyPy -- Python written in Python (actually RPy...)
\end{itemize}

\vfill
{\Large CPython:} Interpreter implimented in C\\
-- allows close connection with C libraries (and C++, Fortran, etc)

\vfill
We will use CPython 2.7 for this workshop
\end{frame}


\begin{frame}[fragile]{Using Python}

{All you need for Python:}
\begin{itemize}
  \item  A good programmer's text editor
    \begin{itemize}
      \item Good Python mode
      \item Particularly indentation!
    \end{itemize}
  \item  The command line to run code
  \item  The interactive shell
    \begin{itemize}
      \item regular interpreter
      \item \verb+IPython+ is an excellent enhancement\\
        \url{http://ipython.org/}
    \end{itemize}
\end{itemize}

\vspace{.2in}
There are lots of Editors, IDES, etc.:\\
   maybe you'll find one you like.

\end{frame} 

\begin{frame}[fragile]{Running Python Code}

\begin{itemize}
  \item At an interpreter prompt:\\
   \begin{verbatim}
     $ python 
     >>> print 'Hello, world!' 
     Hello, world!
   \end{verbatim}
\end{itemize}

\end{frame} 

\begin{frame}[fragile]{Running Python Modules}


{\Large Running Modules}\\[0.05in]
-- a file that contains Python code, filename ends with \verb+.py+

 \begin{enumerate}
    \item \verb+$ python hello.py+  -- must be in current working directory

    \item \verb+$ python -m hello+  -- any module on PYTHONPATH anywhere on the system

    \item \verb+$ ./hello.py+       -- put \verb+#!/usr/env/python+ at top of module (Unix)
   
    \item \verb+$ python -i hello.py+  -- import module, remain in interactive session 

    \item \verb+>>> import hello+    -- at the python prompt -- importing a module executes its contents

    \item \verb+run hello.py+    -- at the IPython prompt -- running a module brings the names into the interactive namespace
\end{enumerate}

\end{frame} 

\begin{frame}[fragile]{Documentation}

{\Large \url{www.python.org} docs:}

\url{http://docs.python.org/index.html}

\vspace{0.25in}
{\Large Particularly the library reference:}

\url{http://docs.python.org/library/index.html}

\vspace{0.25in}
(The tutorial is pretty good, too)

\end{frame} 


\begin{frame}[fragile]{docstrings}

{\Large ``docstrings'': docs embedded in the code}

\vfill
{\Large Designed to be read when working on/with the code}

\vfill 
{\Large But can be accessed interactively}

\vfill
{\Large Best / Easiest way: IPython's  \verb+?+}

\begin{verbatim}
In [123]: list?
Type:       type
String Form:<type 'list'>
Namespace:  Python builtin
Docstring:
list() -> new empty list
list(iterable) -> new list initialized from iterable's items
\end{verbatim}

\end{frame} 

\begin{frame}[fragile]{Documentation}

{\LARGEï¿¼\bf google}

\vspace{0.25in}
But  be careful!

\vspace{0.25in}
Lots of great info out there!

\vspace{0.25in}
Most of it is opinionated and out of date.\\
(might still be correct, though!)

\end{frame} 


\begin{frame}[fragile]{Lab}

\vfill
Get the gitHub project:

\vfill
\url{https://github.com/PythonCHB/IRIS_Python_Class}

\vfill
{\small
\url{https://github.com/PythonCHB/IRIS_Python_Class.git}
}
\vfill

\end{frame} 


\begin{frame}[fragile]{Lab}

{\Large Getting everyone on-line and at a command line.}

\begin{itemize}
    \item Do a \verb+git clone+ of the project
    \item Start up the Python interpreter:\\
          \verb+$ python+ [\verb=ctrl+D= (\verb|ctrl+Z| on Windows)or \verb|exit()| to exit]
    \item Run \verb+hello.py+ (in the \verb+Session01/code+ dir)
    \item Open \verb|hello.py| in your editor, change it, and save it.
    \begin{itemize}    
        \item (Optional) Start up \verb+IPython+ \\
          \verb+$ ipython+ ( also \verb=ctrl+D=, etc. to exit )
         \item Run \verb+hello.py+ in \verb+IPython+
         \item use \verb+?+ in \verb+IPython+ on anything...
    \end{itemize}    
    \item if you have time:\\
\url{http://learnpythonthehardway.org/book/ex1.html}\\
\url{http://learnpythonthehardway.org/book/ex2.html}

...
    
\end{itemize}

\end{frame} 


\section{Values, Expressions, and Types}

\begin{frame}[fragile]{Code structure}

\vfill
{\large Each line is a piece of code}

\vfill
{\large {\bf Comments:} everything following a \verb|#| is a comment}


\vfill
{\large {\bf Expression:} something that results in a value: \verb|3+4|}

\vfill
{\large {\bf Statement:} Line of code that does not return a value: \\
        \verb|print "this"|}

\vfill
{\large Blocks of code are delimited by a colon and indentation:
\begin{verbatim}
def a_function():
    a_new_code_block
end_of_the_block
\end{verbatim}
}

\vfill
\end{frame}

\begin{frame}[fragile]{The print statement}

{\large
Kind of obvious, but handy when playing with code:

\vfill
\verb|print something| prints \verb|something| to the console.

\vfill
Can print multiple things: \verb|print "the value is", 5|

\vfill
Automatically adds a newline.

\vfill
You can suppress the newline with a comma: \\
\verb|print "the value is",|\\
\verb|print 5|

\vfill
Any python object can be printed\\
(though it might not be pretty...)

}

\end{frame}

\begin{frame}[fragile]{Values, expressions, and types}

{\large Values (data) vs. variables (names with values)}

\begin{itemize}
    \item  Values are pieces of unnamed data: \verb+42, 'Hello, world',+

    \item  In Python, all values are objects\\
      Try \verb+dir(42)+ - lots going on behind the curtain! (demo)

    \item  Every value belongs to a type: integer, float, str, ...  (demo)

    \item  An expression is made up of values and operators, is evaluated to
        produce a value:  \verb!2 + 2!, etc.

    \item  Python interpreter can be used as a calculator to evaluate expressions (demo)

    \item  Integer vs. float arithmetic (demo)

    \item  Type errors - checked at run time only (demo)
  
    \item  Type conversions (demo)
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Variables}

{\large Variables are names for values (objects)}

-- Variables don't have a type; values do -- 
this is where the dynamic comes from

\begin{verbatim}
ï¿¼>>> type(42)
<type 'int'>
>>> type(3.14)
<type 'float'>
>>> a = 42
>>> b = 3.14
>>> type(a)
<type 'int'>
>>> a = b
>>> type(a)
<type 'float'>
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Assignment}

{\Large Assignment is really name binding: }
\begin{itemize}
  \item Attaching a name to a value
  \item A value can have many names (or none!)
\end{itemize}

\vfill
{\large \verb|=| assigns (binds a name)}

\vfill
{\large \verb|+=| also an assignment: \verb|a += 1| same as \verb|a = a+1|}

\hspace{0.1in}also: \verb|-=, *=, /=, **=, \%=|

(not quite -- really in-place assignment for mutables....)

\end{frame}


\begin{frame}[fragile]{Multiple Assignment}

{\large You can assign multiple variables from multiple expressions in one statement}

\vfill
\verb|i, j = 2 + x,  3 * y| \# commas separate variables on lhs, exprs on rhs

\vfill
{\large Python evaluates all the expressions on the right before doing any assignments}

\vfill
\verb|i, j = j, i| \# parlor trick: swap in one statement

\vfill
\large{These are just tricks, but multiple assignment is more helpful in other contexts}

\vfill
(more on what's really going on later...)

\vfill
(demo)
\end{frame}


\begin{frame}[fragile]{Deleting}

{\large You can't actually delete anything in python...}

\vfill

{\large \verb|del| only unbinds a name}

\vfill
\begin{verbatim}
a = 5
b = a
del a
\end{verbatim}

The object is still there...python will only delete it if there are no references to it.

\vfill
(demo)

\end{frame}


\begin{frame}[fragile]{equality and identity}

{\large
\vspace{0.1in}
\verb|==| checks equality

\vspace{0.1in}
\verb|is| checks identity

\vspace{0.1in}
\verb|id()| queries identity
}

\vspace{0.2in}
(demo)


\end{frame}


\begin{frame}[fragile]{Operator Precedence}

{Operator Precedence determines what evaluates first:}

\verb^4 + 3 * 5 != (4 + 3) * 5^  --  Use parentheses !

Precedence of common operators:

Arithmetic \\
\verb!**! \\
\verb!+x, -x! \\	
\verb!*, /, %!	\\
\verb!+, -! \\

Comparisons:

\verb^<, <=, >, >=, !=, ==^

Boolean operators:
 
\verb!or, and, not!

Membership and Identity:

\verb!in, not in, is, is not!

\end{frame}



\begin{frame}[fragile]{string literals}

\begin{verbatim}
'a string'
"also a string"
"a string with an apostophe: isn't it cool?"
' a string with an embedded "quote" '
""" a multi-line
string
all in one
"""
"a string with an \n escaped character"

r'a "raw" string the \n comes through as a \n'
 
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{key words}

{\Large  A bunch:}

\vspace{0.2in}
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{and the built-ins..}

{\Large  Try this: 

\vspace{0.2in}
\verb+>>> dir(__builtins__)+

}
\end{frame}


\begin{frame}[fragile]{Lab}

{\large From LPTHW }

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex3.html}

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex4.html}

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex5.html}

(and 6 -- 8 if you get bored...)

\end{frame}

\section{Functions}

\begin{frame}[fragile]{Functions}

\vfill
{\Large What is a function?}

\vfill
{\large A function is a self-contained chunk of code}

\vfill
{\large You use them when you need the same code to run multiple times,
or in multiple parts of the program.}

\vfill
\hspace{1in}{\Large (DRY) }

\vfill
{\large Or just to keep the code clean}

\vfill
{\large Functions can take and return information}

\end{frame}


\begin{frame}[fragile]{Functions}

{\Large Minimal Function does nothing}

\begin{verbatim}
ï¿¼def <name>():
    <statement>
\end{verbatim}

\vspace{0.25in}
{\Large Pass Statement (Note the indentation!)}
\begin{verbatim}
ï¿¼def <name>():
    pass
\end{verbatim}


\end{frame}

\begin{frame}[fragile]{Functions: def}

{\large \verb+def+ is a statement:}
\begin{itemize}
  \item it is executed
  \item it creates a local variable
\end{itemize}

\vspace{0.2in}{\largeï¿¼function defs must be executed before the functions can be called}

\pause
\vspace{0.2in}{\largeï¿¼functions call functions -- this makes a stack -- that's all a trace back is}

\end{frame}

\begin{frame}[fragile]{Functions: Call Stack}

\begin{verbatim}
def exceptional():
    print "I am exceptional!"
    print 1/0
def passive():
    pass
def doer():
    passive()
    exceptional()
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: Tracebacks}

\begin{verbatim}
I am exceptional!
Traceback (most recent call last):
  File "functions.py", line 15, in <module>
    doer()
  File "functions.py", line 12, in doer
    exceptional()
  File "functions.py", line 5, in exceptional
    print 1/0
ZeroDivisionError: integer division or modulo by zero
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large Every function ends with a \verb+return+}

\begin{verbatim}
def five():
    return 5
\end{verbatim}

{\Large Actually simplest function}
\begin{verbatim}
def fun():
    return None
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large if you don't put \verb+return+ there, python will:}

\begin{verbatim}
In [123]: def fun():
   .....:     pass
In [124]: result = fun()
In [125]: print result
None
\end{verbatim}

{\Large note that the interpreter eats \verb+None+}

\end{frame}


\begin{frame}{Functions: return}

\vspace{0.25in}
{\Large Only one return statement will ever be executed.}

\pause
\vspace{0.25in}
{\Large Ever.}

\pause
\vspace{0.25in}
{\Large Anything after a executed return statement will never get run.}

\vspace{0.25in}
{\Large ï¿¼This is useful when debugging! }

\end{frame}


\begin{frame}[fragile]{Functions: return}

{\Large functions can return multiple results}

\begin{verbatim}
def fun():
    return 1,2,3

In [149]: fun()
Out[149]: (1, 2, 3)
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large remember multiple assignment?}

\begin{verbatim}
In [150]: x,y,z = fun()

In [151]: x
Out[151]: 1

In [152]: y
Out[152]: 2

In [153]: z
Out[153]: 3
\end{verbatim}

\end{frame}

% \begin{frame}[fragile]{Functions: return}

% {\Large Actually a tuple of results...}

% \begin{verbatim}
% In [154]: t = fun()

% In [155]: t
% Out[155]: (1, 2, 3)

% In [156]: type(t)
% Out[156]: tuple
% \end{verbatim}

% {\Large Multiple assignment is really "tuple unpacking"}

% \end{frame}


\begin{frame}[fragile]{Functions: parameters}

{\Large function parameters: in definition}

\begin{verbatim}
def fun(x, y, z):
     q = x + y + z
     print x, y, z, q
\end{verbatim}

{\Large x, y, z are local names -- so is q}

\end{frame}

\begin{frame}[fragile]{Functions: arguments}

{\Large function arguments: when calling}

\begin{verbatim}
def fun(x, y, z):
     print x, y, z
\end{verbatim}
\begin{verbatim}
In [138]: fun(3, 4, 5)

3 4 5
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 32
y = 33
z = 34
def fun(y, z):
     print x, y, z
\end{verbatim}
\begin{verbatim}
In [141]: fun(3,4)

32 3 4
\end{verbatim}
{\Large x is global, y, z are local}

\end{frame}

\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 3
def f():
    y = x
    x = 5
    print x
    print y
\end{verbatim}
  
{\Large What happens when we call \verb+f()+?}

\end{frame}

\begin{frame}[fragile]{Functions: local vs. global}

{\Large Gotcha!}

\begin{verbatim}
In [134]: f()
---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
/Users/Chris/<ipython-input-132-9225fa53a20a> in f()
      1 def f():
----> 2     y = x
      3     x = 5
      4     print x
      5     print y
\end{verbatim}
  
{\Large you are going to assign x -- so it's local}

\end{frame}

\begin{frame}[fragile]{Scopes}

\vspace{0.5in}
{\Largeï¿¼There is a \verb+global+ statement}

\pause
\vspace{0.5in}
{\LARGE Don't use it!}

\end{frame}

\begin{frame}[fragile]{Scopes}

\vspace{0.5in}
{\Largeï¿¼good discussion of scopes:}

\vspace{0.5in}
\url{http://docs.python.org/tutorial/classes.html#python-Â­âscopes-Â­âand-Â­ânamespaces}

\end{frame}

\begin{frame}[fragile]{Recursion}

\vspace{0.5in}
{\Largeï¿¼Recursion is calling a function from itself.}

\vspace{0.5in}
{\Largeï¿¼Max stack depth, function call overhead.}

\vspace{0.5in}
{\Largeï¿¼Because of these two(?), recursion isn't used {\bf that} often in Python.}

\end{frame}

\begin{frame}[fragile]{Lab: functions}

{\Large write a function that:}
\begin{itemize}
  \item takes a number and returns the square and cube of that number
   -- use variables to store the results
  \item takes a string and a number, and returns a new string containing the input string repeated the given number of times
  \item calls another function to do part of its job.
  \item Problems in \verb|Session01\draw_grid.rst|
  
\end{itemize}

\end{frame}
\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 32
def fun(y, z):
    print x, y, z

fun(3,4)

32 3 4
\end{verbatim}
{\large x is global, y and z local}

\vfill
{\Large Use global variables mostly for constants}

\end{frame}


%----------------------------------
\begin{frame}[fragile]{Recursion}

\vfill
{\Largeï¿¼Recursion is calling a function from itself.}

\vfill
{\Largeï¿¼Max stack depth, function call overhead.}

\vfill
{\Largeï¿¼Because of these two(?), recursion isn't used {\bf that} often in Python.}

\vfill
(demo: factorial)
\end{frame}

%----------------------------------
\begin{frame}[fragile]{Tuple Unpacking}

{\Large Remember: \verb| x,y = 3,4| ?}

\vfill
{\Large Really ``tuple unpacking'': \verb| (x, y) = (3, 4)|}

\vfill
{\Large This works in function arguments, too:}

\begin{verbatim}
>>> def a_fun( (a, b), (c, d) ):
...     print a, b, c, d
... 
>>> t, u = (3,4), (5,6)
>>> 
>>> a_fun(t, u)
3 4 5 6
\end{verbatim}
(demo)
\end{frame}

%----------------------------------
\begin{frame}[fragile]{Lab: more with functions}

{\Large Write a function that:}
\begin{itemize}
  \item computes the distance between two points:\\
        dist = sqrt( (x1-x2)**2 + (y1-y2)**2 )\\
        using tuple unpacking...
  \item Take some code with functions, add this to each function:\\
        \verb|print locals()|
  \item Computes the Fibonacci series with a recursive function:\\
  f(0) = 0; f(1) = 1\\
  f(n) = f(n-1) + f(n-2)\\
  0, 1, 1, 2, 3, 5, 8, 13, 21, ...\\
  (If time: a non-recursive version)
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Follow Up}

Recommended Reading:
\begin{itemize}
  \item Think Python: Chapters 1--7 \\
  \item Dive Into Python: Chapters 1--3 \\
  \item LPTHW: ex. 1--10, 18-21 \\
\end{itemize}


\vfill
Coding is the only way to learn to code: 
CodingBat exercises are a good way to build skills.

visit \url{http://codingbat.com}

Do a few -- its fun!

\end{frame}


\end{document}

 