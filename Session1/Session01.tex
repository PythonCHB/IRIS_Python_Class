\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[IRIS Python Workshop Seesion 1]{General Introduction, Basic Data Types, Functions, Conditionals and Looping}
\author{Christopher Barker}
\institute{IRIS}
\date{October 15, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
\tableofcontents
\end{frame}

\section{Intro to the Class}


\begin{frame}[fragile]{Instructor}

{\large Christopher Barker: \url{PythonCHB@gmail.com} }

\vfill
First computer: Commodore Pet -- 8k RAM, Basic

\vfill
Passed through: Pascal, Scheme, Fortran

\vfill
Then a long Break: Theater Arts Major, Scenery, Lighting...

\vfill
PhD Coastal Engineering: Fortran, then Linux and MATLAB

\vfill
Now: Discovered Python in 1998 -- Never looked back

\end{frame}

\begin{frame}{Python}

{\Large     My Python use now:}
\begin{itemize}
   \item Lots of text file crunching / data processing
   \item Desktop GUIs (wxPython)
   \item Computational code
   \item wrapping C/C++ code      
   \item web apps (Pylons, Pyramid)
   \item GIS processing
   \item Ask me about ``BILS'' 
\end{itemize}
\end{frame}


\begin{frame}{Who are you?}

{\Large A bit about you:}
\begin{itemize}
  \item Name
  \item What do you do at IRIS?
  \item programing background (languages)
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Class Structure}

{\LARGE github project} \\
\url{https://github.com/PythonCHB/IRIS_Python_Class}

\vfill
{\large Presentations, Sample Code, etc:}

{\small
\begin{verbatim}
git clone https://github.com/PythonCHB/IRIS_Python_Class.git
\end{verbatim}
}
\end{frame}

\begin{frame}{Class Structure}

{\Large Very informal structure: more tutorial/workshop than formal class}

\vfill
{\large \bf Class Time:}
  \begin{itemize}
     \item Some lecture, lots of demos
     \item Lab time: lots of hand-on practice
     \item Later, Rinse, Repeat.....
  \end{itemize}

\vfill
Interrupt me with questions -- please!

\vfill
(Some of the best learning prompted by questions)


\end{frame}

\begin{frame}{Python Features}
 
{\Large Gets many things right:}
\begin{itemize}
  \item  Readable -- looks nice, makes sense
  \item  No ideology about best way to program -- 
   object-oriented programming,  functional, etc.
  \item  No platform preference -- Windows, Mac, Linux, ...
  \item  Easy to connect to other languages -- C, Fortran - essential for science/math
  \item  Large standard library 
  \item  Even larger network of external packages
  \item  Countless conveniences, large and small, make it pleasant to work with
\end{itemize}
\end{frame}

\section{What is Python?}

\begin{frame}{What is Python?}
    \begin{itemize}
      \item Dynamic
      \item Object oriented
      \item Byte-compiled
      \item interpreted
      \item ....
    \end{itemize}
\end{frame}


\begin{frame}{Python Features}

{\Large Features:}

\begin{itemize}
  \item  Unlike C, C++, C\#, Java ... More like Ruby, Lisp, Perl, Matlab, Mathematica ...
  \item  Dynamic - no type declarations
    \begin{itemize}
      \item programs are shorter
      \item programs are more flexible
      \item less code means fewer bugs
    \end{itemize}
  \item  Interpreted - no separate compile, build steps - programming process is simpler
\end{itemize}

\end{frame}

\begin{frame}[fragile]{What's a Dynamic language}

{Strong, Dynamic typing.}

 - Type checking and dispatch happen at run-time

\vspace{0.25in}
{\Large \verb!X = A+B!}
\vspace{0.1in}
\begin{itemize}
\pause
  \item What is A?
  \item What is B?
  \item What does it mean to add them?
\vspace{0.2in}
\pause
  \item A and B can change at any time before this process
\end{itemize}

\end{frame} 


\begin{frame}{Duck Typing}

\vspace{0.25in}
{\center \Large ``If it looks like a duck, and quacks like a duck -- it's probably a duck''}

\pause
\vspace{0.5in}
{\center \Large If an object behaves as expected at run-time, it's the right type.}

\end{frame}


\begin{frame}{Python Versions}

{\Large Python 3.* (``py3k'')}

\vfill
Updated version -- removed the ``warts'' allowed to break code

\vfill
(but really not all that different)

\vfill
Adoption is growing fast, but a few key packages still not supported.
(\url{https://python3wos.appspot.com/})

\vfill
{\Large We'll be using Python 2.7}

\end{frame}


\begin{frame}{Implementations}

\begin{itemize}
    \item Jython (JVM)
    \item Iron Python (.NET)
    \item PyPy -- Python written in Python (actually RPy...)
\end{itemize}

\vfill
{\Large CPython:} Interpreter implimented in C\\
-- allows close connection with C libraries (and C++, Fortran, etc)

\vfill
We will use CPython 2.7 for this workshop
\end{frame}


\begin{frame}[fragile]{Using Python}

{All you need for Python:}
\begin{itemize}
  \item  A good programmer's text editor
    \begin{itemize}
      \item Good Python mode
      \item Particularly indentation!
    \end{itemize}
  \item  The command line to run code
  \item  The interactive shell
    \begin{itemize}
      \item regular interpreter
      \item \verb+IPython+ is an excellent enhancement\\
        \url{http://ipython.org/}
    \end{itemize}
\end{itemize}

\vspace{.2in}
There are lots of Editors, IDES, etc.:\\
   maybe you'll find one you like.

\end{frame} 

\begin{frame}[fragile]{Running Python Code}

\begin{itemize}
  \item At an interpreter prompt:\\
   \begin{verbatim}
     $ python 
     >>> print 'Hello, world!' 
     Hello, world!
   \end{verbatim}
\end{itemize}

\end{frame} 

\begin{frame}[fragile]{Running Python Modules}


{\Large Running Modules}\\[0.05in]
-- a file that contains Python code, filename ends with \verb+.py+

 \begin{enumerate}
    \item \verb+$ python hello.py+  -- must be in current working directory

    \item \verb+$ python -m hello+  -- any module on PYTHONPATH anywhere on the system

    \item \verb+$ ./hello.py+       -- put \verb+#!/usr/env/python+ at top of module (Unix)
   
    \item \verb+$ python -i hello.py+  -- import module, remain in interactive session 

    \item \verb+>>> import hello+    -- at the python prompt -- importing a module executes its contents

    \item \verb+run hello.py+    -- at the IPython prompt -- running a module brings the names into the interactive namespace
\end{enumerate}

\end{frame} 

\begin{frame}[fragile]{Documentation}

{\Large \url{www.python.org} docs:}

\url{http://docs.python.org/index.html}

\vspace{0.25in}
{\Large Particularly the library reference:}

\url{http://docs.python.org/library/index.html}

\vspace{0.25in}
(The tutorial is pretty good, too)

\end{frame} 


\begin{frame}[fragile]{docstrings}

{\Large ``docstrings'': docs embedded in the code}

\vfill
{\Large Designed to be read when working on/with the code}

\vfill 
{\Large But can be accessed interactively}

\vfill
{\Large Best / Easiest way: IPython's  \verb+?+}

\begin{verbatim}
In [123]: list?
Type:       type
String Form:<type 'list'>
Namespace:  Python builtin
Docstring:
list() -> new empty list
list(iterable) -> new list initialized from iterable's items
\end{verbatim}

\end{frame} 

\begin{frame}[fragile]{Documentation}

{\LARGEï¿¼\bf google}

\vspace{0.25in}
But  be careful!

\vspace{0.25in}
Lots of great info out there!

\vspace{0.25in}
Most of it is opinionated and out of date.\\
(might still be correct, though!)

\end{frame} 


\begin{frame}[fragile]{Lab}

\vfill
Get the gitHub project:

\vfill
\url{https://github.com/PythonCHB/IRIS_Python_Class}

\vfill
{\small
\url{https://github.com/PythonCHB/IRIS_Python_Class.git}
}
\vfill

\end{frame} 


\begin{frame}[fragile]{Lab}

{\Large Getting everyone on-line and at a command line.}

\begin{itemize}
    \item Do a \verb+git clone+ of the project
    \item Start up the Python interpreter:\\
          \verb+$ python+ [\verb=ctrl+D= (\verb|ctrl+Z| on Windows)or \verb|exit()| to exit]
    \item Run \verb+hello.py+ (in the \verb+Session01/code+ dir)
    \item Open \verb|hello.py| in your editor, change it, and save it.
    \begin{itemize}    
        \item (Optional) Start up \verb+IPython+ \\
          \verb+$ ipython+ ( also \verb=ctrl+D=, etc. to exit )
         \item Run \verb+hello.py+ in \verb+IPython+
         \item use \verb+?+ in \verb+IPython+ on anything...
    \end{itemize}    
    \item if you have time:\\
\url{http://learnpythonthehardway.org/book/ex1.html}\\
\url{http://learnpythonthehardway.org/book/ex2.html}

...
    
\end{itemize}

\end{frame} 


\section{Values, Expressions, and Types}

\begin{frame}[fragile]{Code structure}

\vfill
{\large Each line is a piece of code}

\vfill
{\large {\bf Comments:} everything following a \verb|#| is a comment}


\vfill
{\large {\bf Expression:} something that results in a value: \verb|3+4|}

\vfill
{\large {\bf Statement:} Line of code that does not return a value: \\
        \verb|print "this"|}

\vfill
{\large Blocks of code are delimited by a colon and indentation:
\begin{verbatim}
def a_function():
    a_new_code_block
end_of_the_block
\end{verbatim}
}

\vfill
\end{frame}

\begin{frame}[fragile]{The print statement}

{\large
Kind of obvious, but handy when playing with code:

\vfill
\verb|print something| prints \verb|something| to the console.

\vfill
Can print multiple things: \verb|print "the value is", 5|

\vfill
Automatically adds a newline.

\vfill
You can suppress the newline with a comma: \\
\verb|print "the value is",|\\
\verb|print 5|

\vfill
Any python object can be printed\\
(though it might not be pretty...)

}

\end{frame}

\begin{frame}[fragile]{Values, expressions, and types}

{\large Values (data) vs. variables (names with values)}

\begin{itemize}
    \item  Values are pieces of unnamed data: \verb+42, 'Hello, world',+

    \item  In Python, all values are objects\\
      Try \verb+dir(42)+ - lots going on behind the curtain! (demo)

    \item  Every value belongs to a type: integer, float, str, ...  (demo)

    \item  An expression is made up of values and operators, is evaluated to
        produce a value:  \verb!2 + 2!, etc.

    \item  Python interpreter can be used as a calculator to evaluate expressions (demo)

    \item  Integer vs. float arithmetic (demo)

    \item  Type errors - checked at run time only (demo)
  
    \item  Type conversions (demo)
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Variables}

{\large Variables are names for values (objects)}

-- Variables don't have a type; values do -- 
this is where the dynamic comes from

\begin{verbatim}
ï¿¼>>> type(42)
<type 'int'>
>>> type(3.14)
<type 'float'>
>>> a = 42
>>> b = 3.14
>>> type(a)
<type 'int'>
>>> a = b
>>> type(a)
<type 'float'>
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Assignment}

{\Large Assignment is really name binding: }
\begin{itemize}
  \item Attaching a name to a value
  \item A value can have many names (or none!)
\end{itemize}

\vfill
{\large \verb|=| assigns (binds a name)}

\vfill
{\large \verb|+=| also an assignment: \verb|a += 1| same as \verb|a = a+1|}

\hspace{0.1in}also: \verb|-=, *=, /=, **=, \%=|

(not quite -- really in-place assignment for mutables....)

\end{frame}


\begin{frame}[fragile]{Multiple Assignment}

{\large You can assign multiple variables from multiple expressions in one statement}

\vfill
\verb|i, j = 2 + x,  3 * y| \# commas separate variables on lhs, exprs on rhs

\vfill
{\large Python evaluates all the expressions on the right before doing any assignments}

\vfill
\verb|i, j = j, i| \# parlor trick: swap in one statement

\vfill
\large{These are just tricks, but multiple assignment is more helpful in other contexts}

\vfill
(more on what's really going on later...)

\vfill
(demo)
\end{frame}


\begin{frame}[fragile]{Deleting}

{\large You can't actually delete anything in python...}

\vfill

{\large \verb|del| only unbinds a name}

\vfill
\begin{verbatim}
a = 5
b = a
del a
\end{verbatim}

The object is still there...python will only delete it if there are no references to it.

\vfill
(demo)

\end{frame}


\begin{frame}[fragile]{equality and identity}

{\large
\vspace{0.1in}
\verb|==| checks equality

\vspace{0.1in}
\verb|is| checks identity

\vspace{0.1in}
\verb|id()| queries identity
}

\vspace{0.2in}
(demo)


\end{frame}


\begin{frame}[fragile]{Operator Precedence}

{Operator Precedence determines what evaluates first:}

\verb^4 + 3 * 5 != (4 + 3) * 5^  --  Use parentheses !

Precedence of common operators:

Arithmetic \\
\verb!**! \\
\verb!+x, -x! \\	
\verb!*, /, %!	\\
\verb!+, -! \\

Comparisons:

\verb^<, <=, >, >=, !=, ==^

Boolean operators:
 
\verb!or, and, not!

Membership and Identity:

\verb!in, not in, is, is not!

\end{frame}



\begin{frame}[fragile]{string literals}

\begin{verbatim}
'a string'
"also a string"
"a string with an apostophe: isn't it cool?"
' a string with an embedded "quote" '
""" a multi-line
string
all in one
"""
"a string with an \n escaped character"

r'a "raw" string the \n comes through as a \n'
 
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{key words}

{\Large  A bunch:}

\vspace{0.2in}
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{and the built-ins..}

{\Large  Try this: 

\vspace{0.2in}
\verb+>>> dir(__builtins__)+

}
\end{frame}


\begin{frame}[fragile]{Lab}

{\large From LPTHW }

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex3.html}

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex4.html}

\vspace{0.2in}
\url{http://learnpythonthehardway.org/book/ex5.html}

(and 6 -- 8 if you get bored...)

\end{frame}

\section{Functions}

\begin{frame}[fragile]{Functions}

\vfill
{\Large What is a function?}

\vfill
{\large A function is a self-contained chunk of code}

\vfill
{\large You use them when you need the same code to run multiple times,
or in multiple parts of the program.}

\vfill
\hspace{1in}{\Large (DRY) }

\vfill
{\large Or just to keep the code clean}

\vfill
{\large Functions can take and return information}

\end{frame}


\begin{frame}[fragile]{Functions}

{\Large Minimal Function does nothing}

\begin{verbatim}
ï¿¼def <name>():
    <statement>
\end{verbatim}

\vspace{0.25in}
{\Large Pass Statement (Note the indentation!)}
\begin{verbatim}
ï¿¼def <name>():
    pass
\end{verbatim}


\end{frame}

\begin{frame}[fragile]{Functions: def}

{\large \verb+def+ is a statement:}
\begin{itemize}
  \item it is executed
  \item it creates a local variable
\end{itemize}

\vspace{0.2in}{\largeï¿¼function defs must be executed before the functions can be called}

\pause
\vspace{0.2in}{\largeï¿¼functions call functions -- this makes a stack -- that's all a trace back is}

\end{frame}

\begin{frame}[fragile]{Functions: Call Stack}

\begin{verbatim}
def exceptional():
    print "I am exceptional!"
    print 1/0
def passive():
    pass
def doer():
    passive()
    exceptional()
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: Tracebacks}

\begin{verbatim}
I am exceptional!
Traceback (most recent call last):
  File "functions.py", line 15, in <module>
    doer()
  File "functions.py", line 12, in doer
    exceptional()
  File "functions.py", line 5, in exceptional
    print 1/0
ZeroDivisionError: integer division or modulo by zero
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large Every function ends with a \verb+return+}

\begin{verbatim}
def five():
    return 5
\end{verbatim}

{\Large Actually simplest function}
\begin{verbatim}
def fun():
    return None
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large if you don't put \verb+return+ there, python will:}

\begin{verbatim}
In [123]: def fun():
   .....:     pass
In [124]: result = fun()
In [125]: print result
None
\end{verbatim}

{\Large note that the interpreter eats \verb+None+}

\end{frame}


\begin{frame}{Functions: return}

\vspace{0.25in}
{\Large Only one return statement will ever be executed.}

\pause
\vspace{0.25in}
{\Large Ever.}

\pause
\vspace{0.25in}
{\Large Anything after a executed return statement will never get run.}

\vspace{0.25in}
{\Large ï¿¼This is useful when debugging! }

\end{frame}


\begin{frame}[fragile]{Functions: return}

{\Large functions can return multiple results}

\begin{verbatim}
def fun():
    return 1,2,3

In [149]: fun()
Out[149]: (1, 2, 3)
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Functions: return}

{\Large remember multiple assignment?}

\begin{verbatim}
In [150]: x,y,z = fun()

In [151]: x
Out[151]: 1

In [152]: y
Out[152]: 2

In [153]: z
Out[153]: 3
\end{verbatim}

\end{frame}

% \begin{frame}[fragile]{Functions: return}

% {\Large Actually a tuple of results...}

% \begin{verbatim}
% In [154]: t = fun()

% In [155]: t
% Out[155]: (1, 2, 3)

% In [156]: type(t)
% Out[156]: tuple
% \end{verbatim}

% {\Large Multiple assignment is really "tuple unpacking"}

% \end{frame}


\begin{frame}[fragile]{Functions: parameters}

{\Large function parameters: in definition}

\begin{verbatim}
def fun(x, y, z):
     q = x + y + z
     print x, y, z, q
\end{verbatim}

{\Large x, y, z are local names -- so is q}

\end{frame}

\begin{frame}[fragile]{Functions: arguments}

{\Large function arguments: when calling}

\begin{verbatim}
def fun(x, y, z):
     print x, y, z
\end{verbatim}
\begin{verbatim}
In [138]: fun(3, 4, 5)

3 4 5
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 32
y = 33
z = 34
def fun(y, z):
     print x, y, z
\end{verbatim}
\begin{verbatim}
In [141]: fun(3,4)

32 3 4
\end{verbatim}
{\Large x is global, y, z are local}

\end{frame}

\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 3
def f():
    y = x
    x = 5
    print x
    print y
\end{verbatim}
  
{\Large What happens when we call \verb+f()+?}

\end{frame}

\begin{frame}[fragile]{Functions: local vs. global}

{\Large Gotcha!}

\begin{verbatim}
In [134]: f()
---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
/Users/Chris/<ipython-input-132-9225fa53a20a> in f()
      1 def f():
----> 2     y = x
      3     x = 5
      4     print x
      5     print y
\end{verbatim}
  
{\Large you are going to assign x -- so it's local}

\end{frame}

\begin{frame}[fragile]{Scopes}

\vspace{0.5in}
{\Largeï¿¼There is a \verb+global+ statement}

\pause
\vspace{0.5in}
{\LARGE Don't use it!}

\end{frame}

\begin{frame}[fragile]{Scopes}

\vspace{0.5in}
{\Largeï¿¼good discussion of scopes:}

\vspace{0.5in}
\url{http://docs.python.org/tutorial/classes.html#python-Â­âscopes-Â­âand-Â­ânamespaces}

\end{frame}

\begin{frame}[fragile]{Recursion}

\vspace{0.5in}
{\Largeï¿¼Recursion is calling a function from itself.}

\vspace{0.5in}
{\Largeï¿¼Max stack depth, function call overhead.}

\vspace{0.5in}
{\Largeï¿¼Because of these two(?), recursion isn't used {\bf that} often in Python.}

\end{frame}

\begin{frame}[fragile]{Lab: functions}

{\Large write a function that:}
\begin{itemize}
  \item takes a number and returns the square and cube of that number
   -- use variables to store the results
  \item takes a string and a number, and returns a new string containing the input string repeated the given number of times
  \item calls another function to do part of its job.
  \item Problems in \verb|Session01\draw_grid.rst|
  
\end{itemize}

\end{frame}
\begin{frame}[fragile]{Functions: local vs. global}

\begin{verbatim}
x = 32
def fun(y, z):
    print x, y, z

fun(3,4)

32 3 4
\end{verbatim}
{\large x is global, y and z local}

\vfill
{\Large Use global variables mostly for constants}

\end{frame}


%----------------------------------
\begin{frame}[fragile]{Recursion}

\vfill
{\Largeï¿¼Recursion is calling a function from itself.}

\vfill
{\Largeï¿¼Max stack depth, function call overhead.}

\vfill
{\Largeï¿¼Because of these two(?), recursion isn't used {\bf that} often in Python.}

\vfill
(demo: factorial)
\end{frame}

%----------------------------------
\begin{frame}[fragile]{Tuple Unpacking}

{\Large Remember: \verb| x,y = 3,4| ?}

\vfill
{\Large Really ``tuple unpacking'': \verb| (x, y) = (3, 4)|}

\vfill
{\Large This works in function arguments, too:}

\begin{verbatim}
>>> def a_fun( (a, b), (c, d) ):
...     print a, b, c, d
... 
>>> t, u = (3,4), (5,6)
>>> 
>>> a_fun(t, u)
3 4 5 6
\end{verbatim}
(demo)
\end{frame}

%----------------------------------
\begin{frame}[fragile]{Lab: more with functions}

{\Large Write a function that:}
\begin{itemize}
  \item computes the distance between two points:\\
        dist = sqrt( (x1-x2)**2 + (y1-y2)**2 )\\
        using tuple unpacking...
  \item Take some code with functions, add this to each function:\\
        \verb|print locals()|
  \item Computes the Fibonacci series with a recursive function:\\
  f(0) = 0; f(1) = 1\\
  f(n) = f(n-1) + f(n-2)\\
  0, 1, 1, 2, 3, 5, 8, 13, 21, ...\\
  (If time: a non-recursive version)
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Follow Up}

Recommended Reading:
\begin{itemize}
  \item Think Python: Chapters 1--7 \\
  \item Dive Into Python: Chapters 1--3 \\
  \item LPTHW: ex. 1--10, 18-21 \\
\end{itemize}


\vfill
Coding is the only way to learn to code: 
CodingBat exercises are a good way to build skills.

visit \url{http://codingbat.com}

Do a few -- its fun!

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Boolean Expressions}

% ---------------------------------------------
\begin{frame}[fragile]{Truthiness}

{\Large What is true or false in Python?}

\begin{itemize}
  \item The Booleans: \verb+True+ and \verb+False+
  \item ``Something or Nothing''
\end{itemize}

{\small \url{http://mail.python.org/pipermail/python-dev/2002-April/022107.html} }

\end{frame}

% -------------------------------
\begin{frame}[fragile]{Truthiness}

{\Large ï¿¼Determining Truthiness:}

\vfill
{\Large \verb+bool(something)+ }

\vfill


\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large \verb+False+ }

\begin{itemize}
  \item \verb+None+
  \item \verb+False+
  \item zero of any numeric type, for example, \verb+ 0, 0L, 0.0, 0j+.
  \item any empty sequence, for example, \verb+ '', (), [] +.
  \item any empty mapping, for example, \verb+{}+.
  \item instances of user-defined classes, if the class defines a
        \verb+__nonzero__() or __len__()+ method, when that method
        returns the integer zero or bool value \verb+False+.
\end{itemize}

\url{http://docs.python.org/library/stdtypes.html}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{ \Largeï¿¼Avoid: }

\vspace{0.1in}
\verb+if xx == True:+

\vfill
{ \Largeï¿¼Use: }

\vspace{0.1in}
\verb+if xx:+

\vfill
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large ``Shortcutting''}

\begin{verbatim}
                  if x is false, 
x or y               return y,
                     else return x

                  if x is false,
x and y               return  x
                      else return y

                  if x is false,
not x               return True,
                    else return False 
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large Stringing them together}

\begin{verbatim}
ï¿¼ a or b or c or d

a and b and c and d  
\end{verbatim}

{\Large The first value that defines the result is returned}

\vfill
(demo)
\end{frame}


%---------------------------------------------
\begin{frame}[fragile]{Boolean returns}

{\Large From CodingBat}
\vfill
\begin{verbatim}
def sleep_in(weekday, vacation):
    if weekday == True and vacation == False:
        return False
    else:
        return True
\end{verbatim}

\end{frame}


%---------------------------------------------
\begin{frame}[fragile]{Boolean returns}

{\Large From CodingBat}

%\begin{verbatim}
%def makes10(a, b):
%    return a == 10 or b == 10 or a+b == 10
%\end{verbatim}

\begin{verbatim}
def sleep_in(weekday, vacation):
    return not (weekday == True and vacation == False)
\end{verbatim}

or

\begin{verbatim}
def sleep_in(weekday, vacation):
    return (not weekday) or vacation
\end{verbatim}


\end{frame}


% -------------------------------------------
\begin{frame}[fragile]{bools are ints?}

{\Large bool types are subclasses of integer}

\begin{verbatim}
In [1]: True == 1
Out[1]: True

In [2]: False == 0
Out[2]: True  
\end{verbatim}

{\Large It gets weirder! }

\begin{verbatim}
In [6]: 3 + True
Out[6]: 4
\end{verbatim}

(demo)

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Conditional expression}

{\large A common idiom:}
\begin{verbatim}
if something:
    x = a_value
else:
    x = another_value
\end{verbatim}
\vfill
{\large Also, other languages have a ``ternary operator''}\\
\hspace{0.2in}(C family: \verb|result = a > b ? x : y ;|)

\vfill
{ \Large \verb|y = 5 if x > 2 else 3| }

\vfill
{\large PEP 308:}
(http://www.python.org/dev/peps/pep-0308/)

\end{frame}



%-------------------------------
\begin{frame}[fragile]{LAB}

\begin{itemize}
  \item Look up the \verb+%+ operator. What do these do?\\
    \verb| 10 % 7 == 3 | \\
    \verb| 14 % 7 == 0 |
  \item  Write a program that prints the numbers from 1 to 100 inclusive.
But for multiples of three print ``Fizz'' instead of the number and for the
multiples of five print ``Buzz''. For numbers which are multiples of both three
and five print ``FizzBuzz'' instead.

  \item Re-write a couple CodingBat exercises, using a conditional expression


  \item Re-write a couple CodingBat exercises, returning the direct boolean results\\
\end{itemize}

(use whichever you like, or the ones in: \verb|code/codingbat.rst| )

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Code Structure}

{\Large Python is all about namespaces --  the ``dots'' }

\vfill
\verb|name.another_name|

\vfill
The ``dot'' indicates looking for a name in the namespace of the
given object. It could be:

\begin{itemize}
\item name in a module
\item module in a package
\item attribute of an object
\item method of an object
\end{itemize}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{indenting and blocks}

{\Large  Indenting determines blocks of code }

\vfill
\begin{verbatim}
something:
    some code
    some more code
    another block:
        code in 
        that block
\end{verbatim}

\vfill
{\Large But you need the colon too...}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{indenting and blocks}

{\Large  You can put a one-liner after the colon:}

\vfill
\begin{verbatim}
In [167]: x = 12

In [168]: if x > 4: print x
12
\end{verbatim}

\vfill
{\Large Only do this if it makes it more readable...}

\end{frame}


\begin{frame}[fragile]{Spaces and Tabs}

{\Large  An indent can be:}
\begin{itemize}
  \item Any number of spaces
  \item A tab
  \item tabs and spaces:
    \begin{itemize}
      \item A tab is eight spaces (always!)
      \item Are they eight in your editor?
    \end{itemize}
\end{itemize}

\vfill
{\LARGE Always use four spaces -- really!}

\vfill
(PEP 8)

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{Spaces Elsewhere}

{\Large  Other than indenting -- space doesn't matter}

\vfill
\begin{verbatim}

x = 3*4+12/func(x,y,z)

x = 3*4 + 12 /   func (x,   y, z) 

\end{verbatim}

\vfill
{\Large Choose based on readability/coding style}

\vfill
\center{\LARGE PEP 8}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{Various Brackets}

{\Large Bracket types:}

\begin{itemize}
  \item parentheses \verb+( )+
    \begin{itemize}
      \item tuple literal: \verb+(1,2,3)+
      \item function call: \verb+fun( arg1, arg2 )+
      \item grouping: \verb| (a + b) * c |
    \end{itemize}
  \item square brackets \verb+[ ]+
    \begin{itemize}
      \item list literal: \verb+[1,2,3]+
      \item sequence indexing: \verb+a_string[4]+
    \end{itemize}
  \item curly brackets \verb+{ }+
    \begin{itemize}
      \item dictionary literal: \verb+{"this":3, "that":6}+
      \item (we'll get to those...)
    \end{itemize}
\end{itemize}

\end{frame}


%-----------------------------------
\begin{frame}{modules and packages}

{\Large A module is simply a namespace}

\vfill
{\Large A package is a module with other modules in it}

\vfill
{\Large The code in the module is run when it is imported}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{importing modules}

\begin{verbatim}

import modulename

from modulename import this, that

import modulename as a_new_name
\end{verbatim}

\vfill
(demo)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{importing from packages}

\begin{verbatim}

import packagename.modulename

from packagename.modulename import this, that

from package import modulename

\end{verbatim}
\vfill
(demo)

\vfill
\url{http://effbot.org/zone/import-confusion.htm}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{importing from packages}

\begin{verbatim}
from modulename import *
\end{verbatim}

\vfill
{\LARGE Don't do this!}
\vfill
{\Large (``Namespaces are one honking great idea...'')}

\vfill
(wxPython and numpy example...)

\vfill
Except \emph{maybe} math module

\vfill
(demo)
\end{frame} 


%------------------------------------
\begin{frame}[fragile]{import}

\vfill
If you donât know the module name before execution.

\vfill
\begin{verbatim}
__import__(module)
\end{verbatim}

\vfill
where \verb|module| is a Python string.

\vfill
\end{frame}

\begin{frame}[fragile]{modules and packages}

\vfill
{\Large The code in a module is NOT re-run when imported again
 -- it must be explicitly reloaded to be re-run}

\begin{verbatim}
import modulename

reload(modulename)
\end{verbatim}

(demo)

\begin{verbatim}
import sys
print sys.modules
\end{verbatim}
(demo)
\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large  Experiment with importing different ways:}
\begin{verbatim}
import math
dir(math) # or, in ipython -- math.<tab>
math.sqrt(4)

import math as m
m.sqrt(4)

from math import *
sqrt(4)
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large  Experiment with importing different ways:}
\begin{verbatim}
import sys
print sys.path

import os
print os.path
\end{verbatim}
{\Large You wouldn't want to import * those -- check out}
\begin{verbatim}
os.path.split()
os.path.join()
\end{verbatim}

\vfill
The problem in \verb|Session02/ackerman.rst| 

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Follow Up}

Recommended Reading:
\begin{itemize}
  \item Think Python: Chapters 8, 9, 10, 11, 12
  \item String methods: \url{http://docs.python.org/library/stdtypes.html#string-methods}
  \item Dive Into Python: Chapter 3
\end{itemize}

Do:
\begin{itemize}
    \item Six more CodingBat exercises.
    \item LPTHW: for extra practice with the concepts -- some of:
    \begin{description}
        \item[strings:] ex5, ex6, ex7, ex8, ex9, ex10
        \item[raw\_input(), sys.argv:] ex12, ex13, ex14 (needed for files)
    \end{description}    
\end{itemize}

\vfill
(and any labs you didn't finish in class)

\end{frame}


\end{document}

 