\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[IRIS Python Workshop Session 2a]{Conditionals, Looping, Sequences and Lists}
\author{Christopher Barker}
\institute{IRIS}
\date{October 16, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
\tableofcontents
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Review}

{\Large Questions from yesterday?}

\vfill
{\Large Recursion: python supports it. See:}

{\large \verb|Session1/code/ackerman.rst|}

\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Boolean Expressions}

% ---------------------------------------------
\begin{frame}[fragile]{Truthiness}

{\Large What is true or false in Python?}

\begin{itemize}
  \item The Booleans: \verb+True+ and \verb+False+
  \item ``Something or Nothing''
\end{itemize}

{\small \url{http://mail.python.org/pipermail/python-dev/2002-April/022107.html} }

\end{frame}

% -------------------------------
\begin{frame}[fragile]{Truthiness}

{\Large ￼Determining Truthiness:}

\vfill
{\Large \verb+bool(something)+ }

\vfill


\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large \verb+False+ }

\begin{itemize}
  \item \verb+None+
  \item \verb+False+
  \item zero of any numeric type, for example, \verb+ 0, 0L, 0.0, 0j+.
  \item any empty sequence, for example, \verb+ '', (), [] +.
  \item any empty mapping, for example, \verb+{}+.
  \item instances of user-defined classes, if the class defines a
        \verb+__nonzero__() or __len__()+ method, when that method
        returns the integer zero or bool value \verb+False+.
\end{itemize}

\url{http://docs.python.org/library/stdtypes.html}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{ \Large￼Avoid: }

\vspace{0.1in}
\verb+if xx == True:+

\vfill
{ \Large￼Use: }

\vspace{0.1in}
\verb+if xx:+

\vfill
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large ``Shortcutting''}

\begin{verbatim}
                  if x is false, 
x or y               return y,
                     else return x

                  if x is false,
x and y               return  x
                      else return y

                  if x is false,
not x               return True,
                    else return False 
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}

{\Large Stringing them together}

\begin{verbatim}
￼ a or b or c or d

a and b and c and d  
\end{verbatim}

{\Large The first value that defines the result is returned}

\vfill
(demo)
\end{frame}


%---------------------------------------------
\begin{frame}[fragile]{Boolean returns}

{\Large From CodingBat}

(\url{http://codingbat.com/python})

\begin{verbatim}
def makes10(a, b):
    """Given 2 ints, a and b, return True if one if them is 10
       or if their sum is 10. """
    return a == 10 or b == 10 or a+b == 10
\end{verbatim}

\vfill
\url{http://codingbat.com/prob/p173401}
\begin{verbatim}
def sleep_in(weekday, vacation):
    return not (weekday == True and vacation == False)
\end{verbatim}
or
\begin{verbatim}
def sleep_in(weekday, vacation):
    return (not weekday) or vacation
\end{verbatim}


\end{frame}


% -------------------------------------------
\begin{frame}[fragile]{bools are ints?}

{\Large bool types are subclasses of integer}

\begin{verbatim}
In [1]: True == 1
Out[1]: True

In [2]: False == 0
Out[2]: True  
\end{verbatim}

{\Large It gets weirder! }

\begin{verbatim}
In [6]: 3 + True
Out[6]: 4
\end{verbatim}

(demo)

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Conditional expression}

{\large A common idiom:}
\begin{verbatim}
if something:
    x = a_value
else:
    x = another_value
\end{verbatim}
\vfill
{\large Also, other languages have a ``ternary operator''}\\
\hspace{0.2in}(C family: \verb|result = a > b ? x : y ;|)

\vfill
{ \Large \verb|y = 5 if x > 2 else 3| }

\vfill
{\large PEP 308:}
(http://www.python.org/dev/peps/pep-0308/)

\end{frame}



%-------------------------------
\begin{frame}[fragile]{LAB}

\begin{itemize}
  \item Look up the \verb+%+ operator. What do these do?\\
    \verb| 10 % 7 == 3 | \\
    \verb| 14 % 7 == 0 |
  \item  Write a program that prints the numbers from 1 to 100 inclusive.
But for multiples of three print ``Fizz'' instead of the number and for the
multiples of five print ``Buzz''. For numbers which are multiples of both three
and five print ``FizzBuzz'' instead.

  \item Re-write a couple CodingBat exercises, using a conditional expression


  \item Re-write a couple CodingBat exercises, returning the direct boolean results\\
\end{itemize}

(use whichever you like, or the ones in: \verb|code/codingbat.rst| )

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Code Structure}

{\Large Python is all about namespaces --  the ``dots'' }

\vfill
\verb|name.another_name|

\vfill
The ``dot'' indicates looking for a name in the namespace of the
given object. It could be:

\begin{itemize}
\item name in a module
\item module in a package
\item attribute of an object
\item method of an object
\end{itemize}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{indenting and blocks}

{\Large  Indenting determines blocks of code }

\vfill
\begin{verbatim}
something:
    some code
    some more code
    another block:
        code in 
        that block
\end{verbatim}

\vfill
{\Large But you need the colon too...}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{indenting and blocks}

{\Large  You can put a one-liner after the colon:}

\vfill
\begin{verbatim}
In [167]: x = 12

In [168]: if x > 4: print x
12
\end{verbatim}

\vfill
{\Large Only do this if it makes it more readable...}

\end{frame}


\begin{frame}[fragile]{Spaces and Tabs}

{\Large  An indent can be:}
\begin{itemize}
  \item Any number of spaces
  \item A tab
  \item tabs and spaces:
    \begin{itemize}
      \item A tab is eight spaces (always!)
      \item Are they eight in your editor?
    \end{itemize}
\end{itemize}

\vfill
{\LARGE Always use four spaces -- really!}

\vfill
(PEP 8)

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{Spaces Elsewhere}

{\Large  Other than indenting -- space doesn't matter}

\vfill
\begin{verbatim}

x = 3*4+12/func(x,y,z)

x = 3*4 + 12 /   func (x,   y, z) 

\end{verbatim}

\vfill
{\Large Choose based on readability/coding style}

\vfill
\center{\LARGE PEP 8}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{Various Brackets}

{\Large Bracket types:}

\begin{itemize}
  \item parentheses \verb+( )+
    \begin{itemize}
      \item tuple literal: \verb+(1,2,3)+
      \item function call: \verb+fun( arg1, arg2 )+
      \item grouping: \verb| (a + b) * c |
    \end{itemize}
  \item square brackets \verb+[ ]+
    \begin{itemize}
      \item list literal: \verb+[1,2,3]+
      \item sequence indexing: \verb+a_string[4]+
    \end{itemize}
  \item curly brackets \verb+{ }+
    \begin{itemize}
      \item dictionary literal: \verb+{"this":3, "that":6}+
      \item (we'll get to those...)
    \end{itemize}
\end{itemize}

\end{frame}


%-----------------------------------
\begin{frame}{modules and packages}

{\Large A module is simply a namespace}

\vfill
{\Large A package is a module with other modules in it}

\vfill
{\Large The code in the module is run when it is imported}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{importing modules}

\begin{verbatim}

import modulename

from modulename import this, that

import modulename as a_new_name
\end{verbatim}

\vfill
(demo)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{importing from packages}

\begin{verbatim}

import packagename.modulename

from packagename.modulename import this, that

from package import modulename

\end{verbatim}
\vfill
(demo)

\vfill
\url{http://effbot.org/zone/import-confusion.htm}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{importing from packages}

\begin{verbatim}
from modulename import *
\end{verbatim}

\vfill
{\LARGE Don't do this!}
\vfill
{\Large (``Namespaces are one honking great idea...'')}

\vfill
(wxPython and numpy example...)

\vfill
Except \emph{maybe} math module

\vfill
(demo)
\end{frame} 


%------------------------------------
\begin{frame}[fragile]{import}

\vfill
If you don’t know the module name before execution.

\vfill
\begin{verbatim}
__import__(module)
\end{verbatim}

\vfill
where \verb|module| is a Python string.

\vfill
\end{frame}

\begin{frame}[fragile]{modules and packages}

\vfill
{\Large The code in a module is NOT re-run when imported again
 -- it must be explicitly reloaded to be re-run}

\begin{verbatim}
import modulename

reload(modulename)
\end{verbatim}

(demo)

\begin{verbatim}
import sys
print sys.modules
\end{verbatim}
(demo)
\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large  Experiment with importing different ways:}
\begin{verbatim}
import math
dir(math) # or, in ipython -- math.<tab>
math.sqrt(4)

import math as m
m.sqrt(4)

from math import *
sqrt(4)
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large  Experiment with importing different ways:}
\begin{verbatim}
import sys
print sys.path

import os
print os.path
\end{verbatim}
{\Large You wouldn't want to import * those -- check out}
\begin{verbatim}
os.path.split()
os.path.join()
\end{verbatim}

\end{frame}



% ************************************
\section {Sequences}

\begin{frame}[fragile]{Sequences}

{\Large Sequences are ordered collections of objects}

\vfill
{\Large They can be indexed, sliced, iterated over,...}

\vfill
{\Large They have a length:  \verb+len(sequence)+}

\vfill
{\Large Common sequences (Remember Duck Typing?):}

{\Large
\begin{itemize}
   \item strings
   \item tuples
   \item lists
\end{itemize}
}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large square brackets for indexing: \verb+[]+}

\vfill
{\Large Indexing starts at zero}

\begin{verbatim}
In [98]: s = "this is a string"

In [99]: s[0]
Out[99]: 't'

In [100]: s[5]
Out[100]: 'i'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large Negative indexes count from the end}

\vfill
\begin{verbatim}
In [105]: s = "this is a string"

In [106]: s[-1]
Out[106]: 'g'

In [107]: s[-6]
Out[107]: 's'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing: Pulling a range out of a sequence}

\begin{verbatim}
sequence[start:finish]  

indexes for which:

start <= i < finish
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}
\begin{verbatim}
In [121]: s = "a bunch of words"
In [122]: s[2]
Out[122]: 'b'

In [123]: s[6]
Out[123]: 'h'

In [124]: s[2:6]
Out[124]: 'bunc'

In [125]: s[2:7]
Out[125]: 'bunch'
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large the indexes point to the spaces between the items}

\vfill
\begin{verbatim}
   X   X   X   X   X   X   X   X
 |   |   |   |   |   |   |   | 
 0   1   2   3   4   5   6   7
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing satisfies nifty properties:

\vfill
\begin{verbatim}
len( seq[a:b] ) == b - a

seq[a:b] + seq[b:c] == seq

\end{verbatim}

}

\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing returns a single element}

\begin{verbatim}
In [86]: l
Out[86]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [87]: type(l)
Out[87]: list

In [88]: l[3]
Out[88]: 3

In [89]: type( l[3] )
Out[89]: int
\end{verbatim}
\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Unless it's a string:}

\begin{verbatim}
In [75]: s = "a string"

In [76]: s[3]
Out[76]: 't'

In [77]: type(s[3])
Out[77]: str
\end{verbatim}

\vfill
There is no single character type

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Slicing returns a sequence:}

\begin{verbatim}
In [68]: l
Out[68]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [69]: l[2:4]
Out[69]: [2, 3]
\end{verbatim}

Even if it's one element long

\begin{verbatim}
In [70]: l[2:3]
Out[70]: [2]

In [71]: type(l[2:3])
Out[71]: list
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing out of range produces an error}
\vfill
\begin{verbatim}
In [129]: s = "a bunch of words"
In [130]: s[17]
----> 1 s[17]
IndexError: string index out of range
\end{verbatim}

\vfill
{\Large Slicing just gives you what's there}

\begin{verbatim}
In [131]: s[10:20]
Out[131]: ' words'

In [132]: s[20:30]
Out[132]: ''
\end{verbatim}
(demo)
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Multiplying and slicing}

{\Large from CodingBat: Warmup-1 -- front3}

(\url{http://codingbat.com/prob/p147920})

\begin{verbatim}
def front3(str):
  if len(str) < 3:
    return str+str+str
  else:
    return str[:3]+str[:3]+str[:3]
\end{verbatim}

{\Large or}

\begin{verbatim}
def front3(str):
    return str[:3] * 3
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large from CodingBat: Warmup-1 -- \verb+missing_char+ }

(\url{http://codingbat.com/prob/p149524})

\begin{verbatim}
def missing_char(str, n):
  front = str[0:n]
  l = len(str)-1
  back = str[n+1:l+1]
  return front + back
\end{verbatim}

\begin{verbatim}
def missing_char(str, n):
    return str[:n] + str[n+1:]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large you can skip items, too}

\begin{verbatim}
In [289]: string = "a fairly long string"

In [290]: string[0:15]
Out[290]: 'a fairly long s'

In [291]: string[0:15:2]
Out[291]: 'afil ogs'

In [292]: string[0:15:3]
Out[292]: 'aallg'
\end{verbatim}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{LAB}
Write some functions that:
\begin{itemize}
  \item return a string with the first and last characters exchanged.
  \item return a string with every other character removed
  \item return a string with the first and last 4 characters removed, and every other char in between
  \item return a string reversed (just with slicing)
  \item return a string with the middle, then last, then first third in a new order
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lists, Tuples...}

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List Literals}

\begin{verbatim}
>>> []
[]
>>> list()
[]
>>> [1, 2, 3]
[1, 2, 3]
>>> [1, 3.14, "abc"]
[1, 3.14, 'abc']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List ``type''}

 {\large \hspace{0.1in}(also constructor)}

\begin{verbatim}
>>> type(list)
<type 'type'>
>>> list( (1,2,3) )
[1, 2, 3]
>>> list( "a string" )
\end{verbatim}

\vfill
{\Large Takes any sequence, tries to turn it into a list}

\vfill
{\large like \verb|int()|, \verb|float()|, etc.}


\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Indexing}

 {\Large Indexing just like all sequences}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[2]
'ham'
>>> food[0]
'spam'
>>> food[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Mutability}

{\Large Lists are mutable}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[1] = 'raspberries'
>>> food
['spam', 'raspberries', 'ham']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Elements}

{\Large Each element is a value, and can be in multiple lists and have multiple
names (or no name)}

\begin{verbatim}
  >>> name = 'Brian'
   >>> a = [1, 2, name]
   >>> b = [3, 4, name]
   >>> name
   'Brian'
   >>> a
   [1, 2, 'Brian']
   >>> b
   [3, 4, 'Brian']
   >>> a[2]
   'Brian'
   >>> b[2]
   'Brian'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\Large \verb| .append(), .insert()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.append('sushi')
>>> food
['spam', 'eggs', 'ham', 'sushi']
>>> food.insert(0, 'carrots')
>>> food
['carrots', 'spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb| .extend()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.extend(['fish', 'chips'])
>>> food
['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}

{\large could be any sequence:}

\begin{verbatim}
>>>  food
>>>  ['spam', 'eggs', 'ham']
>>>  silverware = ('fork', 'knife', 'spoon') # a tuple
>>>  food.extend(silverware)
>>>  food
>>>  ['spam', 'eggs', 'ham', 'fork', 'knife', 'spoon']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb|pop(), remove() |}

\begin{verbatim}
In [203]: food = ['spam', 'eggs', 'ham', 'toast']
In [204]: food.pop()
Out[204]: 'toast'
In [205]: food.pop(0)
Out[205]: 'spam'
In [206]: food
Out[206]: ['eggs', 'ham']
In [207]: food.remove('ham')
In [208]: food
Out[208]: ['eggs']
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Constructor}

{\large \verb|list()| accepts any sequence and returns a list of that sequence}
\begin{verbatim}
>>> word = 'Python '
>>> chars = []
>>> for char in word:
...   chars.append(char)
>>> chars
['P', 'y', 't', 'h', 'o', 'n', ' ']
>>> list(word)
['P', 'y', 't', 'h', 'o', 'n', ' ']
\end{verbatim}
\end{frame} 



% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Slicing makes a copy}

\begin{verbatim}
In [227]: food = ['spam', 'eggs', 'ham', 'sushi']

In [228]: some_food = food[1:3]

In [229]: some_food[1] = 'bacon'

In [230]: food
Out[230]: ['spam', 'eggs', 'ham', 'sushi']

In [231]: some_food
Out[231]: ['eggs', 'bacon']
\end{verbatim}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Easy way to copy a whole list}

\begin{verbatim}
In [232]: food
Out[232]: ['spam', 'eggs', 'ham', 'sushi']

In [233]: food2 = food[:]

In [234]: food is food2
Out[234]: False

\end{verbatim}

{\Large but the copy is ``shallow''}: \
\url{http://docs.python.org/library/copy.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\Large ``Shallow'' copy}

\begin{verbatim}
In [249]: food = ['spam', ['eggs', 'ham']]
In [251]: food_copy = food[:]
In [252]: food[1].pop()
Out[252]: 'ham'
In [253]: food
Out[253]: ['spam', ['eggs']]
In [256]: food.pop(0)
Out[256]: 'spam'
In [257]: food
Out[257]: [['eggs']]
In [258]: food_copy
Out[258]: ['spam', ['eggs']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Name Binding}

{\Large Assigning to a name does not copy:}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food_again = food
>>> food_copy = food[:]
>>> food.remove('sushi')
>>> food
['spam', 'eggs', 'ham']
>>> food_again
['spam', 'eggs', 'ham']
>>> food_copy
['spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Iterating}

{\Large Iterating over a list}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food:
...   print x
...
spam
eggs
ham
sushi
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Processing Lists}

{\Large A common pattern}

\begin{verbatim}
filtered = []
for x in somelist:
    if should_be_included(x):
        filtered.append(x)
del(somelist)  # maybe
\end{verbatim}

{\Large you don't want to be deleting items from the list while iterating...}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Mutating Lists}

{\Large if you're going to change the list, iterate over a copy for safety }

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food[:]:
   ...   # change the list somehow
   ...
\end{verbatim}

{\Large insidious bugs otherwise}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{operators vs methods}

{\large What's the difference?}

\begin{verbatim}
   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food = food + more
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']

   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food.extend(more)
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}
(the operator makes a new list...)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{in}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> 'eggs' in food
True
>>> 'chicken feet' in food
False
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{reverse()}


\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.reverse()
>>> food
['ham', 'eggs', 'spam']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{sort()}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food.sort()
>>> food
['eggs', 'ham', 'spam', 'sushi']
\end{verbatim}

\vfill
{\Large note:}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> result = food.sort()
>>> print result
None
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large How should this sort?}

\begin{verbatim}
>>> s
[[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
\end{verbatim}

\pause

\begin{verbatim}
>>> s.sort()
>>> s
[[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'c']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large You can specify your own compare function:}

\begin{verbatim}
In [279]: s = [[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
In [281]: def comp(s1,s2):
   .....:     if s1[1] > s2[1]: return 1
   .....:     elif s1[1]<s2[1]: return -1
   .....:     else:
   .....:         if s1[0] > s2[0]: return 1
   .....:         elif s1[0] < s2[0]: return -1
   .....:     return 0
In [282]: s.sort(comp)
In [283]: s
Out[283]: [[1, 'a'], [2, 'a'], [1, 'b'], [1, 'c'], [2, 'c']]
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\Large
Mixed types can be sorted.
}
\vfill
{\center \Large

``objects of different types always compare unequal, and are ordered
consistently but arbitrarily.''

}

\vfill
\url{http://docs.python.org/reference/expressions.html#not-in}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Searching}

{\Large Finding or Counting items}

\begin{verbatim}
In [288]: l = [3,1,7,5,4,3]

In [289]: l.index(5)
Out[289]: 3

In [290]: l.count(3)
Out[290]: 2
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Performance }

\begin{itemize}
  \item indexing is fast and constant time: O(1)
  \item x in s proportional to n: O(n)
  \item visiting all is proportional to n: O(n)
  \item operating on the end of list is fast and constant time: O(1) \\
     append(), pop()
  \item operating on the front (or middle) of the list depends on n: O(n)\\
     pop(0), insert(0, v) \\
     But, reversing is fast. Also, collections.deque
\end{itemize}

\url{ http://wiki.python.org/moin/TimeComplexity}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Tuples}

\vfill
{\Large Tuples are {\bf immutable} sequences}

\vfill
{\Large Literal: \verb|(1, 2.0, 'this')|}

or

{\Large \verb|tuple(something)|}

\vfill
{\Large None of the list methods that change the contents}

\vfill
{\Large Same indexing, slicing, count, etc.}

\end{frame} 



% ---------------------------------------------
\begin{frame}[fragile]{Lists vs. Tuples}

\vfill
{\Large List or Tuples}

\vfill
{\Large
If it needs to mutable: list

\vfill
If it needs to be immutable: tuple\\
}
\hspace{0.2in}{\large (dict key, safety when passing to a function) }

\vfill
{\Large Otherwise ... taste and convention}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

\vfill
{\LARGE Convention:}

\vfill
{\Large Lists are Collections (homogeneous):\\[0.1in]
-- contain values of the same type \\ 
-- simplifies iterating, sorting, etc
}

\vfill
{\Large tuples are mixed types:\\[0.1in]
-- Group multiple values into one logical thing
-- Kind of like simple C structs.
}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element?
  \item Small collection of values which make a single logical item?
  \item To document that these values won't change?
  \item Build it iteratively?
  \item Transform, filter, etc?
\end{itemize}
}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element? {\bf list}
  \item Small collection of values which make a single logical item? {\bf tuple}
  \item To document that these values won't change? {\bf tuple}
  \item Build it iteratively? {\bf list}
  \item Transform, filter, etc? {\bf list}
\end{itemize}
}

\end{frame} 

\begin{frame}[fragile]{List Docs}

\vfill
{\Large The list docs:}

\vfill
\url{http://docs.python.org/library/stdtypes.html#mutable-sequence-types}

\vfill
(actually any mutable sequence....)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples don't NEED parentheses... }

\begin{verbatim}
In [161]: t = (1,2,3)
In [162]: t
Out[162]: (1, 2, 3)

In [163]: t = 1,2,3
In [164]: t
Out[164]: (1, 2, 3)

In [165]: type(t)
Out[165]: tuple
\end{verbatim}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples do need commas... }

\begin{verbatim}
In [156]: t = ( 3 )

In [157]: type(t)
Out[157]: int

In [158]: t = (3,)
In [159]: t
Out[159]: (3,)

In [160]: type(t)
Out[160]: tuple
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
{\LARGE List Lab}

\vfill
\verb|Session2/code/list_lab.rst|

\vfill

\end{frame}


\section{Looping}

%-------------------------------
\begin{frame}[fragile]{for loops}

{\Large looping through sequences

\begin{verbatim}
for x in sequence:
    do_something_with_x
\end{verbatim}
}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{for loops}

\begin{verbatim}
In [170]: for x in "a string":
   .....:         print x
   .....:     
a
 
s
t
r
i
n
g
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large looping a known number of times..}

\begin{verbatim}
In [171]: for i in range(5):
   .....:     print i
   .....:     
0
1
2
3
4
\end{verbatim}
(you don't need to do anything with i...
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large \verb|range| defined similarly to indexing}

\begin{verbatim}
In [183]: range(4)
Out[183]: [0, 1, 2, 3]

In [184]: range(2,4)
Out[184]: [2, 3]

In [185]: range(2,10,2)
Out[185]: [2, 4, 6, 8]
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Python only loops through a sequence -- not like C, Javascript, etc...}
\begin{verbatim}
for(var i=0; i<arr.length; i++) {
    var value = arr[i];
    alert(i =") "+value);
}
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Use range?}
\begin{verbatim}
In [193]: letters = "Python"

In [194]: for i in range(len(letters)):
   .....:     print letters[i]
   .....:     
P
y
t
h
o
n
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large More Pythonic -- for loops through sequences}
\begin{verbatim}
In [196]: for l in letters:
   .....:     print l
   .....:     
P
y
t
h
o
n
\end{verbatim}
\vfill
{\large Never index in normal cases}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{enumerate}

{\Large If you need an index -- \verb|enumerate|}
\begin{verbatim}
In [197]: for i, l in enumerate(letters):
   .....:     print i, l
   .....:     
0 P
1 y
2 t
3 h
4 o
5 n
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{multiple sequences -- zip}

{\Large If you need to loop though parallel sequences -- \verb|zip|}
\begin{verbatim}
In [200]: first_names = ['Fred', 'Mary', 'Jane']

In [201]: last_names = ['Baker', 'Jones', 'Miller']

In [203]: for first, last in zip(first_names, last_names):
   .....:     print first, last
   .....:     
Fred Baker
Mary Jones
Jane Miller
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{xrange}

{\Large \verb|range| creates the whole list}

\vfill
{\Large \verb|xrange| is a generator -- creates it as it's needed --}

\vfill
{\Large a good idea for large numbers}

\begin{verbatim}
In [207]: for i in xrange(3):
   .....:     print i
0
1
2
\end{verbatim}
(Python 3 -- \verb|range == xrange|)
\end{frame}



%-------------------------------
\begin{frame}[fragile]{for}

{\Large \verb|for| does NOT create a name space:}

\begin{verbatim}
In [172]: x = 10

In [173]: for x in range(3):
   .....:     pass
   .....: 

In [174]: x
Out[174]: 2
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is for when you don't know how many loops you need}

\vfill
{\Large Continues to execute the body until condition is not \verb|True|}

\begin{verbatim}
while a_condition:
   some_code
   in_the_body
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is more general than \verb|for| -- 
you can always express for as while,
but not always vice-versa.}

\vfill

{\Large \verb|while| is more error-prone -- requires some care to terminate}

\vfill
{\Large  loop body must make progress, so condition can become \verb|False| }

\vfill
{\Large  potential error: infinite loops }
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while vs. for}

\begin{verbatim}
letters = 'Python'
i=0
while i < len(letters):
    print letters[i]
    i += 1
\end{verbatim}
vs.
\begin{verbatim}
letters = 'Python'
for c in letters:
    print c
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{while}

{\Large Shortcut: recall -- 0 or empty sequence is \verb|False| }

\vfill
\begin{verbatim}
In [13]: l = range(3)
In [14]: while l: # terminates if l is empty
    print l.pop()
2
1
0
\end{verbatim}
or
\begin{verbatim}
while x:    # terminates if x >= 0 on entry
    ...     # do something with x
    x -= 1  # make progress toward 0
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{break}

{\Large \verb|break| ends a loop early}

\begin{verbatim}
x = 0
while True:
    print x
    if x > 2:
        break
    x = x + 1
In [216]: run for_while.py
0
1
2
3
\end{verbatim}

\vfill
(This is a pretty common idiom)

\end{frame}

%-------------------------------
\begin{frame}[fragile]{break}

{\Large same way with a \verb|for| loop }

\begin{verbatim}
name = "Chris Barker"
for c in name:
    print c,
    if c == "B":
        break
print "I'm done"

C h r i s   B 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| skips to the start of the loop again}

\begin{verbatim}
print "continue in a for loop"
name = "Chris Barker"
for c in name:
    if c == "B":
        continue
    print c,
print "\nI'm done"

continue in a for loop
C h r i s   a r k e r 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| works for a \verb|while| loop too.}

\begin{verbatim}
print "continue in a while loop"
x = 6
while x > 0:
    x = x-1
    if x%2:
        continue
    print x,
print "\nI'm done"

continue in a while loop
4 2 0 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{else again}

{\Large \verb|else| block run if the loop finished naturally -- no \verb|break|}

\begin{verbatim}
print "else in a for loop"
x = 5
for i in range(5):
    print i
    if i == x:
        break
else:
    print "else block run"

\end{verbatim}
\end{frame}

\section{Fun with Strings}

% ---------------------------------------------
\begin{frame}[fragile]{Strings}

{\Large A string literal creates a string type}

\begin{verbatim}
"this is a string"
\end{verbatim}

{\Large Can also use \verb|str()|}

\begin{verbatim}
In [256]: str(34)
Out[256]: '34'
\end{verbatim}
{\Large or "back ticks"}
\begin{verbatim}
In [258]: `34`
Out[258]: '34'
\end{verbatim}
(demo)
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
s.lower()
s.upper()
     ...
s.capitalize()
s.swapcase()
s.title()
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
x in s
s.startswith(x)
s.endswith(x)
...
s.index(x)
s.find(x)
s.rfind(x)
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
s.split()
s.join(list)
...
s.splitlines()
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Joining Strings}

{\Large The Join Method:}

\vfill
\begin{verbatim}
In [289]: t = ("some", "words","to","join")

In [290]: " ".join(t)
Out[290]: 'some words to join'

In [291]: ",".join(t)
Out[291]: 'some,words,to,join'

In [292]: "".join(t)
Out[292]: 'somewordstojoin'
\end{verbatim}

\vfill
(demo -- join)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The string module}

{\Large Lots of handy constants, etc.}
\begin{verbatim}
string.ascii_letters
string.ascii_lowercase 
string.ascii_uppercase  
string.letters
string.hexdigits 
string.whitespace
string.printable
string.digits
string.punctuation      
\end{verbatim}

\vfill
(and the string methods -- legacy)

\vfill
{\small \url{http://docs.python.org/2/library/string.html#module-string} }
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{String Literals}

{\Large Common Escape Sequences}
\vfill
\begin{verbatim}
\\  Backslash (\)   
\a  ASCII Bell (BEL)  
\b  ASCII Backspace (BS)  
\n  ASCII Linefeed (LF)   
\r  ASCII Carriage Return (CR)  
\t  ASCII Horizontal Tab (TAB)  
\ooo  Character with octal value ooo 
\xhh  Character with hex value hh
\end{verbatim}
(\url{http://docs.python.org/release/2.5.2/ref/strings.html})
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Raw Strings}

{\Large Escape Sequences Ignored}
\vfill
\begin{verbatim}
In [408]: print "this\nthat"
this
that
In [409]: print r"this\nthat"
this\nthat
\end{verbatim}

{\Large Gotcha:}
\begin{verbatim}
In [415]: r"\"
SyntaxError: EOL while scanning string literal
\end{verbatim}

\vfill
(handy for regex, windows paths...)
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Character Values}

{\Large Characters in strings are stored as numeric values}

\vfill
{\large ``ASCII'' values: 1-127}

\vfill
{\large ``ANSI'' values: 1-255}


\vfill
{\large To get the value:}
\begin{verbatim}
In [109]: for i in 'Chris':
   .....:     print ord(i), 
67 104 114 105 115

In [110]: for i in (67,104,114,105,115):
   .....:     print chr(i),
C h r i s
\end{verbatim}

\vfill
(later: unicode!)
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Building Strings}

{\Large Please don't do this:

\vfill
\begin{verbatim}
'Hello ' + name + '!'
\end{verbatim}
}
\vfill
(much)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Building Strings}

{\Large Do this instead:

\vfill
\begin{verbatim}
'Hello %s!' % name
\end{verbatim}

\vfill
much faster and safer:

\vfill
easier to modify as code gets complicated
}

\vfill
\url{http://docs.python.org/library/stdtypes.html#string-formatting-operations}
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{String Formatting}

{\Large The string format operator: \%}

\begin{verbatim}
In [261]: "an integer is: %i"%34
Out[261]: 'an integer is: 34'

In [262]: "a floating point is: %f"%34.5
Out[262]: 'a floating point is: 34.500000'

In [263]: "a string is: %s"%"anything"
Out[263]: 'a string is: anything'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{String Formatting}

{\Large multiple arguments:}

\begin{verbatim}
In [264]: "the number %s is %i"%('five', 5)
Out[264]: 'the number five is 5'

In [266]: "the first 3 numbers are: %i, %i, %i"%(1,2,3)
Out[266]: 'the first 3 numbers are: 1, 2, 3'

\end{verbatim}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large Gotcha}

\begin{verbatim}
In [127]: "this is a string with %i formatting item"%1 
Out[127]: 'this is a string with 1 formatting item'

In [128]: "string with %i formatting %s: "%2, "items" 
TypeError: not enough arguments for format string

# Done right:
In [131]: "string with %i formatting %s"%(2, "items")
Out[131]: 'string with 2 formatting items'

In [132]: "string with %i formatting item"%(1,)
Out[132]: 'string with 1 formatting item' 
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large Named arguments}

\begin{verbatim}
'Hello %(name)s!'%{'name':'Joe'}
'Hello Joe!'

'Hello %(name)s, how are you, %(name)s!' %{'name':'Joe'}
'Hello Joe, how are you, Joe!'
\end{verbatim}
\vfill
{\Large That last bit is a dictionary (next week) }

\end{frame}

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large The format operator works with string variables, too:}

\begin{verbatim}
In [45]: s = "%i / %i = %i"

In [46]: a, b = 12, 3

In [47]: s%(a, b, a/b)
Out[47]: '12 / 3 = 4'
\end{verbatim}
\vfill
So you can dynamically build a format string
\end{frame}

%-------------------------------
\begin{frame}[fragile]{Advanced Formatting}

{\Large The format method}

\begin{verbatim}
In [14]: 'Hello {0} {1}!'.format('Joe', 'Barnes')
Out[14]: 'Hello Joe Barnes!'

In [12]: 'Hello {name}!'.format(name='Joe')
Out[12]: 'Hello Joe!'
\end{verbatim}
\vfill
{\Large pick one (probably regular string formatting): \\
  -- get comfy with it }

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large Fun with strings}

\begin{itemize}
  \item Rewrite: \verb| the first 3 numbers are: %i, %i, %i"%(1,2,3)| \\
        for an arbitrary number of numbers...
  \item write a format string that will take:\\
        \verb|( 2, 123.4567, 10000)| \\
        and produce: \\
        \verb|'file_002 :   123.46, 1e+04'|
  \item Write a (really simple) mail merge program
  \item ROT13 -- see next slide
\end{itemize}

\vfill
\url{http://docs.python.org/library/stdtypes.html#string-formatting-operations}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
\Large￼ROT13 encryption

\vfill
Applying ROT13 to a piece of text merely requires examining its alphabetic
characters and replacing each one by the letter 13 places further along in
the alphabet, wrapping back to the beginning if necessary

\begin{itemize}
  \item Implement rot13 decoding 
  \item  decode this message: \\
     \hspace{0.5in} Zntargvp sebz bhgfvqr arne pbeare \\
     \hspace{0.5in} (from a geo-caching hint)
\end{itemize}

\end{frame}



%-------------------------------
\begin{frame}[fragile]{Follow Up}

{\Large Recommended Reading:}
\begin{itemize}
  \item Think Python: Chapt. 9 -- 14
  \item Dive Into Python: Chapt. 6
  \item String methods: \url{http://docs.python.org/library/stdtypes.html#string-methods}
  \item Extra: unicode: \url{http://www.joelonsoftware.com/articles/Unicode.html}
\end{itemize}

\vfill
{\Large Do:}
\begin{itemize}
    \item Finish the LABs
    \item Some CodingBat exercises. 
    \item LPTHW: for extra practice with the concepts -- some of:\\
          excercises 5 -- 14
\end{itemize}

\end{frame}

\end{document}



 